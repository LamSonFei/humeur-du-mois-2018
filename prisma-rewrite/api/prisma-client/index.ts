// Code generated by Prisma (prisma@1.30.0). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  agency: (where?: AgencyWhereInput) => Promise<boolean>;
  employee: (where?: EmployeeWhereInput) => Promise<boolean>;
  survey: (where?: SurveyWhereInput) => Promise<boolean>;
  surveyAnswer: (where?: SurveyAnswerWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  agency: (where: AgencyWhereUniqueInput) => AgencyPromise;
  agencies: (
    args?: {
      where?: AgencyWhereInput;
      orderBy?: AgencyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Agency>;
  agenciesConnection: (
    args?: {
      where?: AgencyWhereInput;
      orderBy?: AgencyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => AgencyConnectionPromise;
  employee: (where: EmployeeWhereUniqueInput) => EmployeePromise;
  employees: (
    args?: {
      where?: EmployeeWhereInput;
      orderBy?: EmployeeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Employee>;
  employeesConnection: (
    args?: {
      where?: EmployeeWhereInput;
      orderBy?: EmployeeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => EmployeeConnectionPromise;
  survey: (where: SurveyWhereUniqueInput) => SurveyPromise;
  surveys: (
    args?: {
      where?: SurveyWhereInput;
      orderBy?: SurveyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Survey>;
  surveysConnection: (
    args?: {
      where?: SurveyWhereInput;
      orderBy?: SurveyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SurveyConnectionPromise;
  surveyAnswers: (
    args?: {
      where?: SurveyAnswerWhereInput;
      orderBy?: SurveyAnswerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<SurveyAnswer>;
  surveyAnswersConnection: (
    args?: {
      where?: SurveyAnswerWhereInput;
      orderBy?: SurveyAnswerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SurveyAnswerConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAgency: (data: AgencyCreateInput) => AgencyPromise;
  updateAgency: (
    args: { data: AgencyUpdateInput; where: AgencyWhereUniqueInput }
  ) => AgencyPromise;
  updateManyAgencies: (
    args: { data: AgencyUpdateManyMutationInput; where?: AgencyWhereInput }
  ) => BatchPayloadPromise;
  upsertAgency: (
    args: {
      where: AgencyWhereUniqueInput;
      create: AgencyCreateInput;
      update: AgencyUpdateInput;
    }
  ) => AgencyPromise;
  deleteAgency: (where: AgencyWhereUniqueInput) => AgencyPromise;
  deleteManyAgencies: (where?: AgencyWhereInput) => BatchPayloadPromise;
  createEmployee: (data: EmployeeCreateInput) => EmployeePromise;
  updateEmployee: (
    args: { data: EmployeeUpdateInput; where: EmployeeWhereUniqueInput }
  ) => EmployeePromise;
  updateManyEmployees: (
    args: { data: EmployeeUpdateManyMutationInput; where?: EmployeeWhereInput }
  ) => BatchPayloadPromise;
  upsertEmployee: (
    args: {
      where: EmployeeWhereUniqueInput;
      create: EmployeeCreateInput;
      update: EmployeeUpdateInput;
    }
  ) => EmployeePromise;
  deleteEmployee: (where: EmployeeWhereUniqueInput) => EmployeePromise;
  deleteManyEmployees: (where?: EmployeeWhereInput) => BatchPayloadPromise;
  createSurvey: (data: SurveyCreateInput) => SurveyPromise;
  updateSurvey: (
    args: { data: SurveyUpdateInput; where: SurveyWhereUniqueInput }
  ) => SurveyPromise;
  updateManySurveys: (
    args: { data: SurveyUpdateManyMutationInput; where?: SurveyWhereInput }
  ) => BatchPayloadPromise;
  upsertSurvey: (
    args: {
      where: SurveyWhereUniqueInput;
      create: SurveyCreateInput;
      update: SurveyUpdateInput;
    }
  ) => SurveyPromise;
  deleteSurvey: (where: SurveyWhereUniqueInput) => SurveyPromise;
  deleteManySurveys: (where?: SurveyWhereInput) => BatchPayloadPromise;
  createSurveyAnswer: (data: SurveyAnswerCreateInput) => SurveyAnswerPromise;
  updateManySurveyAnswers: (
    args: {
      data: SurveyAnswerUpdateManyMutationInput;
      where?: SurveyAnswerWhereInput;
    }
  ) => BatchPayloadPromise;
  deleteManySurveyAnswers: (
    where?: SurveyAnswerWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  agency: (
    where?: AgencySubscriptionWhereInput
  ) => AgencySubscriptionPayloadSubscription;
  employee: (
    where?: EmployeeSubscriptionWhereInput
  ) => EmployeeSubscriptionPayloadSubscription;
  survey: (
    where?: SurveySubscriptionWhereInput
  ) => SurveySubscriptionPayloadSubscription;
  surveyAnswer: (
    where?: SurveyAnswerSubscriptionWhereInput
  ) => SurveyAnswerSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type EmployeeOrderByInput =
  | "fullName_ASC"
  | "fullName_DESC"
  | "email_ASC"
  | "email_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SurveyOrderByInput =
  | "iso_ASC"
  | "iso_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type Feeling = "GREAT" | "NOT_THAT_GREAT" | "NOT_GREAT_AT_ALL";

export type AgencyOrderByInput =
  | "name_ASC"
  | "name_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SurveyAnswerOrderByInput =
  | "feeling_ASC"
  | "feeling_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface AgencyCreateInput {
  name: String;
}

export type AgencyWhereUniqueInput = AtLeastOne<{
  name: String;
}>;

export interface SurveyAnswerWhereInput {
  agency?: AgencyWhereInput;
  survey?: SurveyWhereInput;
  feeling?: Feeling;
  feeling_not?: Feeling;
  feeling_in?: Feeling[] | Feeling;
  feeling_not_in?: Feeling[] | Feeling;
  AND?: SurveyAnswerWhereInput[] | SurveyAnswerWhereInput;
  OR?: SurveyAnswerWhereInput[] | SurveyAnswerWhereInput;
  NOT?: SurveyAnswerWhereInput[] | SurveyAnswerWhereInput;
}

export interface EmployeeCreateOneInput {
  create?: EmployeeCreateInput;
  connect?: EmployeeWhereUniqueInput;
}

export interface EmployeeUpsertNestedInput {
  update: EmployeeUpdateDataInput;
  create: EmployeeCreateInput;
}

export interface SurveySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SurveyWhereInput;
  AND?: SurveySubscriptionWhereInput[] | SurveySubscriptionWhereInput;
  OR?: SurveySubscriptionWhereInput[] | SurveySubscriptionWhereInput;
  NOT?: SurveySubscriptionWhereInput[] | SurveySubscriptionWhereInput;
}

export interface AgencyWhereInput {
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: AgencyWhereInput[] | AgencyWhereInput;
  OR?: AgencyWhereInput[] | AgencyWhereInput;
  NOT?: AgencyWhereInput[] | AgencyWhereInput;
}

export interface EmployeeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: EmployeeWhereInput;
  AND?: EmployeeSubscriptionWhereInput[] | EmployeeSubscriptionWhereInput;
  OR?: EmployeeSubscriptionWhereInput[] | EmployeeSubscriptionWhereInput;
  NOT?: EmployeeSubscriptionWhereInput[] | EmployeeSubscriptionWhereInput;
}

export interface AgencyUpsertNestedInput {
  update: AgencyUpdateDataInput;
  create: AgencyCreateInput;
}

export interface SurveyAnswerUpdateManyMutationInput {
  feeling?: Feeling;
}

export interface AgencyUpdateDataInput {
  name?: String;
}

export type SurveyWhereUniqueInput = AtLeastOne<{
  iso: String;
}>;

export interface AgencyUpdateOneInput {
  create?: AgencyCreateInput;
  update?: AgencyUpdateDataInput;
  upsert?: AgencyUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: AgencyWhereUniqueInput;
}

export interface SurveyWhereInput {
  iso?: String;
  iso_not?: String;
  iso_in?: String[] | String;
  iso_not_in?: String[] | String;
  iso_lt?: String;
  iso_lte?: String;
  iso_gt?: String;
  iso_gte?: String;
  iso_contains?: String;
  iso_not_contains?: String;
  iso_starts_with?: String;
  iso_not_starts_with?: String;
  iso_ends_with?: String;
  iso_not_ends_with?: String;
  AND?: SurveyWhereInput[] | SurveyWhereInput;
  OR?: SurveyWhereInput[] | SurveyWhereInput;
  NOT?: SurveyWhereInput[] | SurveyWhereInput;
}

export interface EmployeeUpdateDataInput {
  fullName?: String;
  email?: String;
  manager?: EmployeeUpdateOneInput;
  agency?: AgencyUpdateOneInput;
}

export interface SurveyUpdateInput {
  iso?: String;
}

export interface SurveyAnswerSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SurveyAnswerWhereInput;
  AND?:
    | SurveyAnswerSubscriptionWhereInput[]
    | SurveyAnswerSubscriptionWhereInput;
  OR?:
    | SurveyAnswerSubscriptionWhereInput[]
    | SurveyAnswerSubscriptionWhereInput;
  NOT?:
    | SurveyAnswerSubscriptionWhereInput[]
    | SurveyAnswerSubscriptionWhereInput;
}

export interface EmployeeUpdateManyMutationInput {
  fullName?: String;
  email?: String;
}

export interface AgencySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AgencyWhereInput;
  AND?: AgencySubscriptionWhereInput[] | AgencySubscriptionWhereInput;
  OR?: AgencySubscriptionWhereInput[] | AgencySubscriptionWhereInput;
  NOT?: AgencySubscriptionWhereInput[] | AgencySubscriptionWhereInput;
}

export interface EmployeeCreateInput {
  fullName?: String;
  email: String;
  manager?: EmployeeCreateOneInput;
  agency?: AgencyCreateOneInput;
}

export interface EmployeeUpdateOneInput {
  create?: EmployeeCreateInput;
  update?: EmployeeUpdateDataInput;
  upsert?: EmployeeUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: EmployeeWhereUniqueInput;
}

export interface EmployeeWhereInput {
  fullName?: String;
  fullName_not?: String;
  fullName_in?: String[] | String;
  fullName_not_in?: String[] | String;
  fullName_lt?: String;
  fullName_lte?: String;
  fullName_gt?: String;
  fullName_gte?: String;
  fullName_contains?: String;
  fullName_not_contains?: String;
  fullName_starts_with?: String;
  fullName_not_starts_with?: String;
  fullName_ends_with?: String;
  fullName_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  manager?: EmployeeWhereInput;
  agency?: AgencyWhereInput;
  AND?: EmployeeWhereInput[] | EmployeeWhereInput;
  OR?: EmployeeWhereInput[] | EmployeeWhereInput;
  NOT?: EmployeeWhereInput[] | EmployeeWhereInput;
}

export interface SurveyAnswerCreateInput {
  agency: AgencyCreateOneInput;
  survey: SurveyCreateOneInput;
  feeling: Feeling;
}

export interface AgencyCreateOneInput {
  create?: AgencyCreateInput;
  connect?: AgencyWhereUniqueInput;
}

export interface EmployeeUpdateInput {
  fullName?: String;
  email?: String;
  manager?: EmployeeUpdateOneInput;
  agency?: AgencyUpdateOneInput;
}

export interface AgencyUpdateManyMutationInput {
  name?: String;
}

export interface AgencyUpdateInput {
  name?: String;
}

export interface SurveyUpdateManyMutationInput {
  iso?: String;
}

export interface SurveyCreateOneInput {
  create?: SurveyCreateInput;
  connect?: SurveyWhereUniqueInput;
}

export type EmployeeWhereUniqueInput = AtLeastOne<{
  email: String;
}>;

export interface SurveyCreateInput {
  iso: String;
}

export interface NodeNode {
  id: ID_Output;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface SurveySubscriptionPayload {
  mutation: MutationType;
  node: Survey;
  updatedFields: String[];
  previousValues: SurveyPreviousValues;
}

export interface SurveySubscriptionPayloadPromise
  extends Promise<SurveySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SurveyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SurveyPreviousValuesPromise>() => T;
}

export interface SurveySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SurveySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SurveySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SurveyPreviousValuesSubscription>() => T;
}

export interface Survey {
  iso: String;
}

export interface SurveyPromise extends Promise<Survey>, Fragmentable {
  iso: () => Promise<String>;
}

export interface SurveySubscription
  extends Promise<AsyncIterator<Survey>>,
    Fragmentable {
  iso: () => Promise<AsyncIterator<String>>;
}

export interface SurveyAnswerPreviousValues {
  feeling: Feeling;
}

export interface SurveyAnswerPreviousValuesPromise
  extends Promise<SurveyAnswerPreviousValues>,
    Fragmentable {
  feeling: () => Promise<Feeling>;
}

export interface SurveyAnswerPreviousValuesSubscription
  extends Promise<AsyncIterator<SurveyAnswerPreviousValues>>,
    Fragmentable {
  feeling: () => Promise<AsyncIterator<Feeling>>;
}

export interface AggregateEmployee {
  count: Int;
}

export interface AggregateEmployeePromise
  extends Promise<AggregateEmployee>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEmployeeSubscription
  extends Promise<AsyncIterator<AggregateEmployee>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AgencyEdge {
  node: Agency;
  cursor: String;
}

export interface AgencyEdgePromise extends Promise<AgencyEdge>, Fragmentable {
  node: <T = AgencyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AgencyEdgeSubscription
  extends Promise<AsyncIterator<AgencyEdge>>,
    Fragmentable {
  node: <T = AgencySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface EmployeeEdge {
  node: Employee;
  cursor: String;
}

export interface EmployeeEdgePromise
  extends Promise<EmployeeEdge>,
    Fragmentable {
  node: <T = EmployeePromise>() => T;
  cursor: () => Promise<String>;
}

export interface EmployeeEdgeSubscription
  extends Promise<AsyncIterator<EmployeeEdge>>,
    Fragmentable {
  node: <T = EmployeeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SurveyPreviousValues {
  iso: String;
}

export interface SurveyPreviousValuesPromise
  extends Promise<SurveyPreviousValues>,
    Fragmentable {
  iso: () => Promise<String>;
}

export interface SurveyPreviousValuesSubscription
  extends Promise<AsyncIterator<SurveyPreviousValues>>,
    Fragmentable {
  iso: () => Promise<AsyncIterator<String>>;
}

export interface EmployeeConnection {
  pageInfo: PageInfo;
  edges: EmployeeEdge[];
}

export interface EmployeeConnectionPromise
  extends Promise<EmployeeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EmployeeEdge>>() => T;
  aggregate: <T = AggregateEmployeePromise>() => T;
}

export interface EmployeeConnectionSubscription
  extends Promise<AsyncIterator<EmployeeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EmployeeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEmployeeSubscription>() => T;
}

export interface SurveyAnswerEdge {
  node: SurveyAnswer;
  cursor: String;
}

export interface SurveyAnswerEdgePromise
  extends Promise<SurveyAnswerEdge>,
    Fragmentable {
  node: <T = SurveyAnswerPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SurveyAnswerEdgeSubscription
  extends Promise<AsyncIterator<SurveyAnswerEdge>>,
    Fragmentable {
  node: <T = SurveyAnswerSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Agency {
  name: String;
}

export interface AgencyPromise extends Promise<Agency>, Fragmentable {
  name: () => Promise<String>;
}

export interface AgencySubscription
  extends Promise<AsyncIterator<Agency>>,
    Fragmentable {
  name: () => Promise<AsyncIterator<String>>;
}

export interface SurveyAnswer {
  feeling: Feeling;
}

export interface SurveyAnswerPromise
  extends Promise<SurveyAnswer>,
    Fragmentable {
  agency: <T = AgencyPromise>() => T;
  survey: <T = SurveyPromise>() => T;
  feeling: () => Promise<Feeling>;
}

export interface SurveyAnswerSubscription
  extends Promise<AsyncIterator<SurveyAnswer>>,
    Fragmentable {
  agency: <T = AgencySubscription>() => T;
  survey: <T = SurveySubscription>() => T;
  feeling: () => Promise<AsyncIterator<Feeling>>;
}

export interface AgencySubscriptionPayload {
  mutation: MutationType;
  node: Agency;
  updatedFields: String[];
  previousValues: AgencyPreviousValues;
}

export interface AgencySubscriptionPayloadPromise
  extends Promise<AgencySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AgencyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AgencyPreviousValuesPromise>() => T;
}

export interface AgencySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AgencySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AgencySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AgencyPreviousValuesSubscription>() => T;
}

export interface AggregateSurvey {
  count: Int;
}

export interface AggregateSurveyPromise
  extends Promise<AggregateSurvey>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSurveySubscription
  extends Promise<AsyncIterator<AggregateSurvey>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AgencyPreviousValues {
  name: String;
}

export interface AgencyPreviousValuesPromise
  extends Promise<AgencyPreviousValues>,
    Fragmentable {
  name: () => Promise<String>;
}

export interface AgencyPreviousValuesSubscription
  extends Promise<AsyncIterator<AgencyPreviousValues>>,
    Fragmentable {
  name: () => Promise<AsyncIterator<String>>;
}

export interface SurveyConnection {
  pageInfo: PageInfo;
  edges: SurveyEdge[];
}

export interface SurveyConnectionPromise
  extends Promise<SurveyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SurveyEdge>>() => T;
  aggregate: <T = AggregateSurveyPromise>() => T;
}

export interface SurveyConnectionSubscription
  extends Promise<AsyncIterator<SurveyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SurveyEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSurveySubscription>() => T;
}

export interface AggregateAgency {
  count: Int;
}

export interface AggregateAgencyPromise
  extends Promise<AggregateAgency>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAgencySubscription
  extends Promise<AsyncIterator<AggregateAgency>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Employee {
  fullName?: String;
  email: String;
}

export interface EmployeePromise extends Promise<Employee>, Fragmentable {
  fullName: () => Promise<String>;
  email: () => Promise<String>;
  manager: <T = EmployeePromise>() => T;
  agency: <T = AgencyPromise>() => T;
}

export interface EmployeeSubscription
  extends Promise<AsyncIterator<Employee>>,
    Fragmentable {
  fullName: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  manager: <T = EmployeeSubscription>() => T;
  agency: <T = AgencySubscription>() => T;
}

export interface EmployeePreviousValues {
  fullName?: String;
  email: String;
}

export interface EmployeePreviousValuesPromise
  extends Promise<EmployeePreviousValues>,
    Fragmentable {
  fullName: () => Promise<String>;
  email: () => Promise<String>;
}

export interface EmployeePreviousValuesSubscription
  extends Promise<AsyncIterator<EmployeePreviousValues>>,
    Fragmentable {
  fullName: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
}

export interface EmployeeSubscriptionPayload {
  mutation: MutationType;
  node: Employee;
  updatedFields: String[];
  previousValues: EmployeePreviousValues;
}

export interface EmployeeSubscriptionPayloadPromise
  extends Promise<EmployeeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EmployeePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EmployeePreviousValuesPromise>() => T;
}

export interface EmployeeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EmployeeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EmployeeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EmployeePreviousValuesSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSurveyAnswer {
  count: Int;
}

export interface AggregateSurveyAnswerPromise
  extends Promise<AggregateSurveyAnswer>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSurveyAnswerSubscription
  extends Promise<AsyncIterator<AggregateSurveyAnswer>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AgencyConnection {
  pageInfo: PageInfo;
  edges: AgencyEdge[];
}

export interface AgencyConnectionPromise
  extends Promise<AgencyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AgencyEdge>>() => T;
  aggregate: <T = AggregateAgencyPromise>() => T;
}

export interface AgencyConnectionSubscription
  extends Promise<AsyncIterator<AgencyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AgencyEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAgencySubscription>() => T;
}

export interface SurveyEdge {
  node: Survey;
  cursor: String;
}

export interface SurveyEdgePromise extends Promise<SurveyEdge>, Fragmentable {
  node: <T = SurveyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SurveyEdgeSubscription
  extends Promise<AsyncIterator<SurveyEdge>>,
    Fragmentable {
  node: <T = SurveySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SurveyAnswerSubscriptionPayload {
  mutation: MutationType;
  node: SurveyAnswer;
  updatedFields: String[];
  previousValues: SurveyAnswerPreviousValues;
}

export interface SurveyAnswerSubscriptionPayloadPromise
  extends Promise<SurveyAnswerSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SurveyAnswerPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SurveyAnswerPreviousValuesPromise>() => T;
}

export interface SurveyAnswerSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SurveyAnswerSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SurveyAnswerSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SurveyAnswerPreviousValuesSubscription>() => T;
}

export interface SurveyAnswerConnection {
  pageInfo: PageInfo;
  edges: SurveyAnswerEdge[];
}

export interface SurveyAnswerConnectionPromise
  extends Promise<SurveyAnswerConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SurveyAnswerEdge>>() => T;
  aggregate: <T = AggregateSurveyAnswerPromise>() => T;
}

export interface SurveyAnswerConnectionSubscription
  extends Promise<AsyncIterator<SurveyAnswerConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SurveyAnswerEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSurveyAnswerSubscription>() => T;
}

export type Long = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Agency",
    embedded: false
  },
  {
    name: "Employee",
    embedded: false
  },
  {
    name: "Survey",
    embedded: false
  },
  {
    name: "Feeling",
    embedded: false
  },
  {
    name: "SurveyAnswer",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `${process.env["PRISMA_ENDPOINT"]}`,
  secret: `${process.env["PRISMA_SECRET"]}`
});
export const prisma = new Prisma();
